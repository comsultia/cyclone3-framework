#!/usr/bin/perl
# USE UTF-8 !!!
package Tomahawk::module;
use open ':utf8', ':std';
use encoding 'utf8';
use utf8;
use strict;



=head1 NAME

411-poll_view.lite.mdl

=head1 DESCRIPTION

Lite view of poll

=head1 DEPENDS

=over

=back

=cut



=head1 INPUTS

=over

=item *

B<db_name> - database name

=item *

B<sql_ID> - requested poll ID

=item *

B<sql_status> - required status (default 'Y')

=item *

B<sql_lng> - required language (default is current)

=back

=cut



=head1 XSGN

=over

=item *

B<TMP> - poll item

=item *

B<ANSWER> - answer

=item *

B<%db_*%> - poll database variables

=back

=cut



sub execute
{
	my %env=@_;
	Tomahawk::GetXSGN('-convertvars'=>1) || return undef;
	
	$env{'db_name'}=$App::401::db_name unless $env{'db_name'};
	
	$env{'sql_lng'}=$env{'lng'} unless $env{'sql_lng'};
	$env{'sql_status'}='Y' unless $env{'sql_status'};
	
	my $no_data=1;

	my $sql_cat = "`poll`.`ID_category` IN ('$env{'ID_category'}') AND" if($env{'ID_category'});
	my $sql_entity = "`poll`.`ID_entity` IN ('$env{'ID_entity'}') AND" if($env{'ID_entity'});

	my $sql=qq{
		SELECT
			`poll`.*
		FROM
			`$env{'db_name'}`.`a411_poll` AS `poll`
		WHERE
			$sql_cat
			$sql_entity
			`poll`.`lng`='$env{'sql_lng'}' AND
			`poll`.`status` IN ('$env{'sql_status'}')
		LIMIT 1
	};
	my %sth0=TOM::Database::SQL::execute($sql,'log'=>1);
	if(!$sth0{'rows'} && $XSGN{'TMP_no-data'})
	{
		$XSGN{'TMP'}=$XSGN{'TMP_no-data'};
		return 1;
	}
	elsif (!$sth0{'rows'})
	{
		die "can't select poll with this attributes\n";
	}
	my %db0_line=$sth0{'sth'}->fetchhash();
	
	# select answers
	my $sql=qq{
		SELECT
			`poll_answer`.*,
			(
				SELECT COUNT(*)
				FROM `$env{'db_name'}`.`a411_poll_vote`
				WHERE ID_answer=`poll_answer`.ID_entity
			) AS vote_count
		FROM
			`$env{'db_name'}`.`a411_poll_answer` AS `poll_answer`
		WHERE
			`poll_answer`.`ID_poll`='$db0_line{'ID_entity'}' AND
			`poll_answer`.`lng`='$env{'sql_lng'}' AND
			`poll_answer`.`status` IN ('$env{'sql_status'}')
		ORDER BY
			`poll_answer`.ID_entity
	};
	my %sth1=TOM::Database::SQL::execute($sql,'log'=>1);
	
	my $votes_total;
	my @percentages;
	my @votes;
	
	my $counter = 0;
	
	while (my %db1_line=$sth1{'sth'}->fetchhash())
	{
		my $answer=$XSGN{'answer'};
		
		$votes_total+=$db1_line{'vote_count'};
		$votes[$counter] = $db1_line{'vote_count'};
		
		$answer=~s|<%db_vote_count_percent%>|<%vote_count_percent_$counter%>|g;
		
		$answer=~s|<%poll_db_(.*?)%>|$db0_line{$1}|g;
		$answer=~s|<%db_(.*?)%>|$db1_line{$1}|g;
		
		$counter++;
		
		$answer=~s|<%counter%>|$counter|g;
		
		$XSGN{'TMP'}=~s|<#answer#>|$answer|;
	}
	
	my $total_percent=0;
	
	for(my $tmp=0; $tmp<scalar(@votes); $tmp++)
	{
		my $var = 0;
		$var=int($votes[$tmp]/($votes_total/100)) if ($votes[$tmp]>0);
		$percentages[$tmp] = $var;
		$total_percent += $var;
	}
	
	if(($total_percent>0) && ($total_percent<100))
	{
 		my $highest=0;

 		for(my $tmp=0; $tmp<scalar(@percentages); $tmp++)
 		{
 			if($percentages[$tmp]>$percentages[$highest])
 			{
 				$highest=$tmp;
 			}
 		}
 		$percentages[$highest] += (100-$total_percent);
	}
	
	for(my $tmp=0; $tmp<scalar(@votes); $tmp++)
	{
		$XSGN{'TMP'}=~s|<%vote_count_percent_$tmp%>|$percentages[$tmp]|g;
	}
	
	$XSGN{'TMP'}=~s|<%db_(.*?)%>|$db0_line{$1}|g;
	
	return 1;
}


our $authors="open\@comsultia.com";

=head1 AUTHORS

Comsultia, Ltd. (open@comsultia.com)

=cut

1;
