#!/usr/bin/env c3-job
package Cyclone3::job;
use parent 'TOM::Engine::job::module';
use open ':utf8', ':std';
use if $] < 5.018, 'encoding','utf8';
use utf8;
use strict;

use Ext::Elastic::_init;
use Data::Dumper;

sub execute
{
	my $self=shift;
	my $env=$self->env;
	return if $self->running({'max'=>(3600*12)}); # check if not already running
	
	if (!$Ext::Elastic_rlog && !$Ext::Elastic)
	{
		return 1;
	}
	
	$Ext::Elastic = $Ext::Elastic_rlog
		|| $Ext::Elastic;	
	$Ext::Elastic->{'request_timeout'} = 300;
	
	main::_log("manage=".$Ext::Elastic_rlog->{'_manage'});
	
	my $Elastic=Search::Elasticsearch->new($Ext::Elastic);
	
	if (!$Elastic)
	{
		return 1;
	}
	
	my @filter=[{"terms" => {"hd" => [$TOM::domain || 'undef']}}];
	
	if ($Ext::Elastic_rlog->{'_manage'})
	{
		# check config
		my $temp_version=1.16;
		my $temp_data={};
		eval {$temp_data=$Elastic->indices->get_template('name'=>'logstash-*');};
		if ($temp_data->{'logstash-*'}->{'mappings'}->{'fluentd'}->{'_meta'}->{'version'} < $temp_version)
		{
			main::_log_stdout("updating template to version $temp_version");
			$Elastic->indices->put_template(
				'name'=>'logstash-*',
				'body' => {
					'timeout' => 600000,
					'template'=>'logstash-*',
					'settings' => {
						"number_of_shards" => 4,
						"number_of_replicas" => 0, # at creation time of indice don't allocate between nodes
						"index.routing.allocation.exclude.tag" => "weak"
					},
					'mappings' => {
						'fluentd' => {
							"_meta" => {
								"version" => $temp_version
							},
							'properties' => {
								
								'@timestamp' => {
									"type" => "date"
								},
								
								'a' => { # archived?
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'p' => { # pid
									'type' => 'integer',
								},
								'h' => { # hostname
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'hd' => { # host domain
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'l' => { # level
									'type' => 'integer'
								},
								'o' => { # helps to natural order
									'type' => 'long'
								},
								'd' => { # domain
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'dm' => { # domain master
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'c' => { # code
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'e' => { # engine
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'f' => { # fault
									'type' => 'integer',
								},
								't' => { # log name / type
									'type' => 'string',
									'index' => 'not_analyzed'
								},
								'm' => { # message
									'type' => 'string'
								},
							},
							
							'dynamic_templates' => [
								{'string' => {
									"match" => "*_s",
									"mapping" => {
										"type" => "string",
										"index" => "not_analyzed"
									}
								}},
								{'text' => {
									"match" => "*_t",
									"mapping" => {
										"type" => "string"
									}
								}},
								{'integer' => {
									"match" => "*_i",
									"mapping" => {
										"type" => "integer"
									}
								}},
								{'float' => {
									"match" => "*_f",
									"mapping" => {
										"type" => "float"
									}
								}},
								{'date' => {
									"match" => "*_d",
									"mapping" => {
										"type" => "date"
									}
								}}
							]
							
						}
					}
				}
			);
		}
	}
	
	my $nodes_weak = 0;
	my $nodes_strong = 0;	
	my $nodes_data = 0;
	
	if ($Ext::Elastic_rlog->{'_manage'})
	{
		my $node_stats  = $Elastic->cluster->stats();
		$nodes_data = $node_stats->{'nodes'}->{'count'}->{'data_only'} + $node_stats->{'nodes'}->{'count'}->{'master_data'};
		$node_stats  = $Elastic->nodes->stats();
		foreach my $node (keys %{$node_stats->{'nodes'}})
		{
			$nodes_weak =+ 1
				if $node_stats->{'nodes'}->{$node}->{'attributes'}->{'tag'}=~/weak/;
			$nodes_strong =+ 1
				if $node_stats->{'nodes'}->{$node}->{'attributes'}->{'tag'}=~/strong/;
		}
		
		main::_log("data_nodes=$nodes_data strong=$nodes_strong weak=$nodes_weak");
		# re-occupy
		$nodes_weak ||= $nodes_data-$nodes_strong || $nodes_data;
		$nodes_strong ||= $nodes_data-$nodes_weak || $nodes_data;	
	}
	
	my @indices_list;
	
	if ($Ext::Elastic_rlog->{'_manage'})
	{
		main::_log("checking .marvel indices");
		my $indices=$Elastic->indices->stats('index' => '.marvel-*')->{'indices'};
		my $settings=$Elastic->indices->get_settings('index' => '.marvel-*');
		foreach my $indice (sort keys %{$indices})
		{
			next unless $indice=~/^\.marvel-\d/;
			my $old = int((time() - int($settings->{$indice}->{'settings'}->{'index'}->{'creation_date'}/1000))/86400);
			if ($old >= 3)
			{
				main::_log("'$indice' old $old, removing");
				$Elastic->indices->delete('index' => $indice);
			}
		}
	}
	
	main::_log("checking indices");
	my $indices=$Elastic->indices->stats('index' => 'logstash-*')->{'indices'};
	my $settings=$Elastic->indices->get_settings('index' => 'logstash-*');
	foreach my $indice (sort keys %{$indices})
	{
		
		if ($Ext::Elastic_rlog->{'_manage'})
		{
			
			if (!$indices->{$indice}->{'total'}->{'docs'}->{'count'})
			{
				main::_log(" indice $indice is empty, removing");
				$Elastic->indices->delete('index' => $indice);
				next;
			}
			
			my $tags;
			if ($settings->{$indice}->{'settings'}->{'index'}->{'routing'}
				&& $settings->{$indice}->{'settings'}->{'index'}->{'routing'}->{'allocation'}
				&& $settings->{$indice}->{'settings'}->{'index'}->{'routing'}->{'allocation'}->{'exclude'}
				&& $settings->{$indice}->{'settings'}->{'index'}->{'routing'}->{'allocation'}->{'exclude'}->{'tag'}
			)
			{
	#			print Dumper($settings->{$indice}->{'settings'}->{'index'}->{'routing'}->{'allocation'}->{'exclude'}->{'tag'});
				$tags=$settings->{$indice}->{'settings'}->{'index'}->{'routing'}->{'allocation'}->{'exclude'}->{'tag'};
			}
			
			my $old = int((time() - int($settings->{$indice}->{'settings'}->{'index'}->{'creation_date'}/1000))/86400);
			my $rel=($indices->{$indice}->{'total'}->{'docs'}->{'deleted'}/$indices->{$indice}->{'total'}->{'docs'}->{'count'});
			main::_log(" indice $indice docs=".$indices->{$indice}->{'total'}->{'docs'}->{'count'}." deleted=".$indices->{$indice}->{'total'}->{'docs'}->{'deleted'}."(".int($rel*100)."%) replicas=".$settings->{$indice}->{'settings'}->{'index'}->{'number_of_replicas'}." segments=".$indices->{$indice}->{'total'}->{'segments'}->{'count'}." old=".$old."d exclude=$tags");
			
			
			if ($old >= $TOM::DEBUG_log_type{'pub'}{'max_days'}) # old indices
			{
				my $tags_='strong,medium';
				if ($tags ne $tags_)
				{
					main::_log("  change routing out of '$tags_'");
					$Elastic->indices->put_settings(
						'index' => $indice,
						'body' => {
							"index.routing.allocation.exclude.tag" => $tags_
						}
					);
				}
				
				my $replicas=$nodes_data-$nodes_strong-1;
				if ($settings->{$indice}->{'settings'}->{'index'}->{'number_of_replicas'} != $replicas)
				{
					main::_log("  change replicas to $replicas");
					$Elastic->indices->put_settings(
						'index' => $indice,
						'body' => {
							"index.number_of_replicas" => $replicas
						}
					);
				}
			}
			elsif ($old >= 2) # not live indices
			{
				my $tags_='weak';
				if ($tags ne $tags_)
				{
					main::_log("  change routing out of '$tags_'");
					$Elastic->indices->put_settings(
						'index' => $indice,
						'body' => {
							"index.routing.allocation.exclude.tag" => $tags_
						}
					);
				}
				
				my $replicas=$nodes_data-$nodes_weak-1;
				if ($settings->{$indice}->{'settings'}->{'index'}->{'number_of_replicas'} != $replicas)
				{
					main::_log("  change replicas to $replicas");
					$Elastic->indices->put_settings(
						'index' => $indice,
						'body' => {
							"index.number_of_replicas" => $replicas
						}
					);
				}
			}
			else # live indice
			{
				my $tags_='weak';
				if ($tags ne $tags_)
				{
					main::_log("  change routing out of '$tags_'");
					$Elastic->indices->put_settings(
						'index' => $indice,
						'body' => {
							"index.routing.allocation.exclude.tag" => $tags_
						}
					);
				}
				
				my $replicas=$nodes_strong-1;
				if ($settings->{$indice}->{'settings'}->{'index'}->{'number_of_replicas'} != $replicas)
				{
					main::_log("  change replicas to $replicas");
					$Elastic->indices->put_settings(
						'index' => $indice,
						'body' => {
							"index.number_of_replicas" => $replicas
						}
					);
				}
			}
			
			if ($rel>=0.15)
			{
				main::_log("  optimize");
				eval {$Elastic->indices->optimize('index' => $indice,'only_expunge_deletes' => 1);};
				if ($@)
				{
					main::_log($@,1);
				}
				last;
			}
		}
		
		push @indices_list,$indice;
	}
	
#	return 1;
	
	foreach my $indice (sort @indices_list)
	{
		# at first, search oldest entry
		my $results = $Elastic->search(
			'index' => $indice,
			'type' => 'fluentd',
			'body'  => {
				'timeout' => 10000, # 10 seconds
				"size" => 1,
				"aggregations" => {
					"oldest" => {
						"min" => {
							'field' => "\@timestamp"
						}
					}
				}
			}
		);
		
		#my $old=
		my $old = int((time() - int($results->{'aggregations'}->{'oldest'}->{'value'}/1000))/86400);
		
		if ($Ext::Elastic_rlog->{'_manage'} && $old > ($TOM::DEBUG_log_type{'pub'}{'max_days'}+1) && $indice=~/\d\d\d\d\-\d\d\-\d\d$/)
		{
			my $indice_new=$indice;
				$indice_new=~s/\-\d\d$//;
			main::_log("'$indice' is old dayindex, moving to monthindex '$indice_new'");
			
			my $i;
			my $bulk_delete = $Elastic->bulk_helper(
				'index'		=> $indice,
				'type'  		=> 'fluentd',
				'verbose'	=> 0,
			);
			my $bulk = $Elastic->bulk_helper(
				'index'		=> $indice_new,
				'type'  		=> 'fluentd',
				'verbose'	=> 0,
				'on_success'  => sub {
					my ($action,$response) = @_;
					$i++;
					main::_log("reindex [$i]") if ($i/1000 == int($i/1000));
					$bulk_delete->delete({'id' => $response->{'_id'}});
				},
			);
			
			$bulk->reindex(
				'source'  => {
					'index'			=>	$indice,
					'size'			=>	10000,
					'search_type'	=>	'scan',
				}
			);
			
			$bulk->flush();
			$bulk_delete->flush();
			
			main::_log(" moved");
		}
		
		main::_log("'$indice' preparing data removal (indice old $old days)");
		
		# at second, create facet
		my $results = $Elastic->search(
			'index' => $indice,
			'type' => 'fluentd',
			'body'  => {
				'timeout' => 10000, # 10 seconds
				
				"size" => 0,
				"aggregations" => {
					"top_t" => {
						"terms" => {
							'field' => "t",
							"size" => 200,
						}
					}
				},
				'query' => {
					'filtered' => {
						'filter' => {
							'bool' => {
								'must' => [
									@filter
								]
							}
						}
					}
				}
			}
		);
		
	#	print Dumper($results);
		
		foreach my $type (@{$results->{'aggregations'}->{'top_t'}->{'buckets'}})
		{
			$type->{'key'}=~s|^cyclone3\.||;
			
			main::_log(" '$type->{'key'}' docs=$type->{'doc_count'}");
			
			my $max_days=$TOM::DEBUG_log_type{$type->{'key'}}->{'max_days'} || $TOM::DEBUG_log_type{'_default'}->{'max_days'};
			
			if ($max_days <= $old)
			{
				main::_log("  remove older than $max_days days");
				
				my $results = $Elastic->delete_by_query(
					'index' => $indice,
					'type' => 'fluentd',
					'body'  => {
		#				"size" => 0,
						'query' => {
							'filtered' => {
								'filter' => {
									'bool' => {
										'must' => [
											{"terms" => {"t" => ["cyclone3.".$type->{'key'}]}},
											{
												"range" => {
													'@timestamp' => {
														"lt" => 'now-'.$max_days.'d'
													}
												}
											},@filter
										]
									}
								}
							}
						},
					}
				);
			}
			
			if ($TOM::DEBUG_log_type{$type->{'key'}}->{'fault'})
			{
				$max_days=$TOM::DEBUG_log_type{$type->{'key'}}->{'fault'};
				
				next if $max_days > $old;
				
				main::_log("  remove faults older than $max_days days");
				$Elastic->delete_by_query(
					'index' => $indice,
					'type' => 'fluentd',
					'body'  => {
						'query' => {
							'filtered' => {
								'filter' => {
									'bool' => {
										'must' => [
											{"terms" => {"t" => ["cyclone3.".$type->{'key'}]}},
											{"terms" => {"f" => [1]}},
											{
												"range" => {
													'@timestamp' => {
														"lt" => 'now-'.$max_days.'d'
													}
												}
											},@filter
										]
									}
								}
							}
						},
					}
				);
			}
			
			if ($TOM::DEBUG_log_type{$type->{'key'}}->{'levels'})
			{
				foreach my $level (sort keys %{$TOM::DEBUG_log_type{$type->{'key'}}->{'levels'}})
				{
					$max_days=$TOM::DEBUG_log_type{$type->{'key'}}->{'levels'}->{$level};
					
					next if $max_days > $old;
					
					main::_log("  remove level >=$level older than $max_days days");
					$Elastic->delete_by_query(
						'index' => $indice,
						'type' => 'fluentd',
						'body'  => {
							'query' => {
								'filtered' => {
									'filter' => {
										'bool' => {
											'must' => [
												{"terms" => {"t" => ["cyclone3.".$type->{'key'}]}},
												{"range" => {"l" => {'gte' => $level}}},
												{
													"range" => {
														'@timestamp' => {
															"lt" => 'now-'.$max_days.'d'
														}
													}
												},@filter
											],
											'must_not' => [
												{"terms" => {"f" => [1]}},
											]
										}
									}
								}
							},
						}
					);
				}
			}
		}
	}
	
return 1}
1;
