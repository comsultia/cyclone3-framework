#!/usr/bin/perl
use Term::ANSIColor;
use Time::HiRes;
BEGIN {
	if (!$ENV{'CYCLONE3PATH'}){$ENV{'CYCLONE3PATH'}="/www/TOM" if -d "/www/TOM";$ENV{'CYCLONE3PATH'}="/Cyclone3" if -d "/Cyclone3";}
	require $ENV{'CYCLONE3PATH'}."/.bin/tom3-init";
}
use Term::InKey;
%form=
(
 '--host'	=>	"restart host (eg. www_localhost_com)",
# '-s'		=>	"show all",
);
if (($FORM{h})||($FORM{help})){&help();}


#open(*STDERR,">/dev/null");

use Proc::ProcessTable;
use DateTime;

while(1)
{
	
	
	# cmdline
	# pctcpu
	# rss
	
	my %hosts;
	
	my $t = new Proc::ProcessTable;
	foreach my $p (@{$t->table})
	{
#		next unless $p->{'cmndline'}=~/(\.core\/tom3|perl.*core\.tom)/;
#		print $p->{'cmndline'}."\n";
		next unless $p->{'cmndline'}=~/^.*\/perl $TOM::P\/[^ ]*\/(.*?)$/;
		my $engine=$1;
		
		my $host;
		$p->{'cmndline'}=~s| pwd=.*$||;
		$p->{'cmndline'}=~/$TOM::P\/(.*)\/(.*?)$/;
		my $pwd=$1;
#			$pwd=~s|^.*?/TOM/||;
			$pwd=~s| $||g;
		
		foreach (split('/',$pwd))
		{
			$_=~s/^!// && do
			{
				if ($host){$host=$_.".".$host;next}
				$host=$_;next;
			};
			$host.="/".$_;
		}
		$host=~s|^www\.||;
		$host=~s|/core\.tom$||;
		
#		foreach (keys %{$p})
#		{
#			print $_ . " = ". $p->{$_} . "\n";
#		}
#		exit;
		push @{$hosts{$host}},{
			'engine'=>$engine,
			'size'=>$p->{'size'},
			'rss'=>$p->{'rss'},
			'pctcpu'=>$p->{'pctcpu'},
			'state'=>$p->{'state'},
			'start'=>$p->{'start'},
			'time'=>$p->{'time'},
			'pid'=>$p->{'pid'}
		};
		
	}
	
#	exit;
	
		my $l;
		foreach my $host(sort keys %hosts)
		{
			$l=length($host) if length($host)>$l;
		}
	
		&Clear();
		print color 'reset bold cyan';
		print "[HOST".(" " x ($l-4))."][ENGINE][STAT ][P ][CPU  ][RSS  ][START][TIME ]\n";
		print color 'reset cyan';
		
		my $processes;
		my $cpu;
		my $rss;
		foreach my $host(sort keys %hosts)
		{
			for (0..@{$hosts{$host}}-1)
			{
				$processes++;
				my $setcolor;
				$hosts{$host}[$_]{'state'}="proc" if $hosts{$host}[$_]{'state'} eq "onprocessor";
				if ($hosts{$host}[$_]{'state'} eq "run"){$setcolor = 'reset bold cyan';}
				if ($hosts{$host}[$_]{'state'} eq "proc"){$setcolor = 'reset bold cyan';}
				else {$setcolor = 'reset cyan';}
				print color $setcolor;
				
				# host
				if (!$_){print "[".sprintf("%-".$l."s",$host)."]";}else {print (" " x ($l+2));}
				
				# engine
				$hosts{$host}[$_]{'engine'}=substr($hosts{$host}[$_]{'engine'},0,6);
				print "[".sprintf("%-6s",$hosts{$host}[$_]{'engine'})."]";
				
				# STAT
				print "[";
				print sprintf("%5s",$hosts{$host}[$_]{'state'});
				print color $setcolor;print "]";
				
				# P
				print "[".sprintf("%2s",$_+1)."]";
				
				# CPU
				print "[";
				if ($hosts{$host}[$_]{'pctcpu'} > 1){print color 'bold cyan'}
				if ($hosts{$host}[$_]{'pctcpu'} > 10){print color 'yellow'}
				if ($hosts{$host}[$_]{'pctcpu'} > 30){print color 'bold red'}
				print sprintf('%5s',sprintf('%-2.2f',$hosts{$host}[$_]{'pctcpu'}));print color $setcolor;print "]";
				$cpu+=$hosts{$host}[$_]{'pctcpu'};
				
				# MEM
				$hosts{$host}[$_]{'rss'}=int($hosts{$host}[$_]{'rss'}/1024/1024);
				print "[";
				if ($hosts{$host}[$_]{'rss'} > 50){print color 'yellow'}
				if ($hosts{$host}[$_]{'rss'} > 100){print color 'bold red'}
				print sprintf("%4d",$hosts{$host}[$_]{'rss'});print color $setcolor;print "M]";
				$rss+=$hosts{$host}[$_]{'rss'};
				
				my $dt = DateTime->from_epoch( epoch => $hosts{$host}[$_]{'start'}+(3600*2));
				print "[".sprintf('%02d',$dt->hour).":".sprintf('%02d',$dt->min)."]";
				
				print "[";
				if ((time()-$hosts{$host}[$_]{'start'}) > 1200){print color 'yellow'};
				if ((time()-$hosts{$host}[$_]{'start'}) > 1800){print color 'bold red'};
				print sprintf('%5s',time()-$hosts{$host}[$_]{'start'});
				print color $setcolor;
				print "]";
				
				print " #".$hosts{$host}[$_]{'pid'};
				
				print "\n";
				
			}
			
			
		}
		
		print color 'reset cyan';
		print "[TOTAL".(" " x ($l-5))."]               [". sprintf('%2d',$processes)."][". sprintf('%2.2f',$cpu) ."][" .sprintf('%4s',$rss). "M]\n";
		print color 'reset cyan';
		
		
		#print color 'reset bold cyan';print "*";print "\n";
		Time::HiRes::sleep(3);
#		exit;
	
}




&exit();
