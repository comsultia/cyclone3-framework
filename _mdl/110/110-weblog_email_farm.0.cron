#!/bin/perl
# USE UTF-8 !!!
package CRON::module;
use TOM::Utils::datetime;
use strict;




sub execute
{
	my %env=@_;
	my $date=`date -u "+%a,%e %b %Y %H:%M:%S (%Z)"`;chomp($date);
	my $date=&TOM::Utils::datetime::mail_current();
	# Zlozenie emailu
	# ( druhy statistik )
	#
	# - domeny ( header, menu, skratky )
	# - business performance ( header )
	# - load performance ( header )
	# - processor performance ( header )
	# - avg request time ( header, skratky, info )
	# - paralel requests ( header, skratky, info )
	# - request time ( header )


	# NASTAVENIA

	# Error hlasky
	#if ($cron::P ne $CRON::P){$cron::ERR="WARN: this cron is only for global use!!! ($cron::P ne $CRON::P) ";return undef}

	# databaza
	#if ($TOM::DB_name_STAT eq $TOM::DB_name_TOM){$env{t}="C";}
	#if (!$env{db_130}){$cron::ERR="WARN: db_130 not defined!!!";return undef}
	#$env{db_130}=$TOM::DB_name_TOM;

	# email
	$env{to_email}= $TOM::contact{'TOM'}.";".$TOM::contact{'TECH'}.";".$TOM::contact{'TECH_farm'}.";".$TOM::contact{'WEB'}.";".$TOM::contact{'DEV'};

	# tabulka
	#$env{table}="a130_send";#}else{$env{table}="a130_send";}

	# connect
	Database::connect::multi('stats') || die "cannot connect all databases";

	# boundary do mailu
	my $boundary = "------------060509090608000908080106";

	# jazyk
	$env{lng} = 'sk' unless $env{lng};

	# casy
	# skorigujem cas - nastavim na 0:0:0
	my $time_current = $main::time_current;
	my %tm_correct = Utils::datetime::ctodatetime($time_current,format=>1);
	my $time_correct = $time_current-($tm_correct{hour}*3600+$tm_correct{min}*60+$tm_correct{sec});
	
	my %times = ( 'in' => ($time_correct - 86400), );
	my %tmi = Utils::datetime::ctodatetime($times{in},format=>1);
	$times{text} = { 'in' => "$tmi{year}-$tmi{mom}-$tmi{mday}", };
	$times{sk} = { 'in' => "$tmi{mday}. $tmi{mom}. $tmi{year}", };
	$times{en} = { 'in' => "$tmi{year}-$tmi{mom}-$tmi{mday}", };

	# specific - money
	my $money_86400 = 0;
	my $money_1 = $money_86400 / 86400;

	# texty
	my %TEXTS = (
		'sk' => {
			# hlavicky emailu
			'headers-subject' => "[STAT][a110/weblog] FARM last day",

			# texty pre hlavnu cast emailu
			'email-header' => "Štatistiky návštevnosti častí webov na subdoménach <%domain-name%>",
			'email-term' => "za deň <%day-in%>",
			'email-info' => "Tento prehľad podáva informáciu o návštevnosti jednotlivých sekcií na weboch.",
	
			# spolocne skratky pre vsetky casti
			# -------------
			# zatial ziadne
			# inak 'globals-...'
	
			# texty pre jednotlive casti
			# - vypis typeciek podla domen
			'stats-domains-header' => "všetky domény",
			'stats-domains-domain' => "domain",
			'stats-domains-subdomain' => "subdomain",
			'stats-domains-type' => "TypeID",
			'stats-domains-count' => "count",
			'stats-domains-load_req' => "load_req",
			'stats-domains-load_proc' => "load_proc",
			'stats-domains-fulltime' => "fulltime",
			'stats-domains-efectivity' => "efectivity",
			'stats-domains-money' => "money",
			'stats-domains-summary' => "spolu",
			'stats-domains-totalsummary' => "všetko spolu",
	
			# - business performance
			'stats-performbus-header' => "business performance (by avg request time)",
	
			# - load performance
			'stats-performload-header' => "load performance (by primetime load)",
	
			# - processor performance
			'stats-performproc-header' => "processor performance",
	
			# - avg request time
			'stats-reqtavg-header' => "avg request time",
			'stats-reqtavg-total' => "total",
			'stats-reqtavg-primetime' => "primetime",
			'stats-reqtavg-note1' => "pokial je 'primetime' hodne vacsi ako 'total', znamena to ze farma nebezi optimalne, miera poziadaviek na nu je privelka, je nutne upgradovat hardware alebo optimalizovat.",
			'stats-reqtavg-note2' => "pokial je 'primetime' mierne vacsi ako 'total', znamena to ze farma ani v primetime nieje viac vytazena ako v inom case. pokial je vtedy vacsi aj load, znamena to ze farma je privelmi vytazena cely den",
			'stats-reqtavg-note3' => "pokial je 'total' vacsi ako 'primetime', znamena to ze farma nebezi optimalne, a bezny pocet poziadaviek je primaly na to aby mohol byt napr. cache optimalizovany.",
	
			# - paralel requests
			'stats-parreq-header' => "parallel requests",
			'stats-parreq-parreq' => "parallel requesting",
			'stats-parreq-note1' => "<100% = requesty niesu vykonavane paralelne, vykon stroja umoznuje vykonavat poziadavky linearne zasebou (v percentualnej miere 100%-)",
	
			# - request time
			'stats-reqt-header' => "request time",
		},
	
		'en' => {
		},

	);

	# styly - css
	my $style = <<"STYLE";
<style>
	body { font-family: Arial, Verdana; }

	h1 {
		color: #808285;
		font-family: Arial, Verdana;
	}

	/*.domain { color: #555555; text-align: left; font-size: 15px;  }
	.term { font-size: 14px; font-weight: normal; }
	.info { font-size: 18px; }*/

	.domain { font-size: 18px; }
	.term { font-size: 14px; font-weight: normal; }
	.info { font-size: 14px; font-weight: normal; }

	#page table { margin-bottom: 30px; }

	#page td { border: 1px solid gray; }
	#page th { border: 1px solid gray; text-align: left; }
	#domains td, #domains th { border: none; }
	#domains .tableinfos td, #domains .tableinfos th { border: 1px solid #000; }
</style>
STYLE
	
	# konstrukcia emailu
	my $email = <<"HEADER";
From: "$TOM::hostname" <TOM\@$TOM::hostname>
To: <%TO%>
Subject: <%SUBJECT%>
Date: $date
List-Id: TOM3
MIME-Version: 1.0
Content-Type: multipart/related;
 boundary="$boundary"

This is a multi-part message in MIME format.
--$boundary
Content-Type: text/html;charset="utf-8"
Content-Transfer-Encoding: 7bit

<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
	</head>
	<body>
		<#STYLE#>

		<h1>
			<img src="cid:part1.webcom.logo\@webcom.sk" alt="webcom logo" border="0" /><br /><br />
			<span class="domain"><%header%></span><br />
			<span class="term"><%term%></span><br />
			<span class="info"><%info%></span>
		</h1>

		<div id="page">
			<#BODY#>
		</div>
	</body>
</html>
--$boundary
Content-Type: image/gif;
 name="webcom_logo.gif"
Content-ID: <part1.webcom.logo\@webcom.sk>
Content-Transfer-Encoding: base64
Content-Disposition: inline;
 filename="webcom_logo.gif"

R0lGODlhlgAcAMQAAL/Awd/g4O0bI/f395iam7i5urCxss/Q0YiKjJCSk+/v8NfY2Ofn6Kip
q8fIyfaNke84P/zU1v3i4/RxdvebnvV/hKCho4CChP///wAAAAAAAAAAAAAAAAAAAAAAAAAA
ACH5BAAAAAAALAAAAACWABwAAAX/ICaOZGmeaIpaV6u+cCzPL0MQFuLQfD+yLp9wSBQxEg6A
I0DYFZ8l4AVKrZ4aAIChYGEgrFApeEy1BACWRgGTIBPF7rjPrDUYMF95D67vwwBYAEcOFn40
fIaJJQM3Cwo5DIoxiJKSA4QWBQqVMJScnxgWohabJwOiDSmPowMkCgAELS0EmidSCgYJshcE
AK0qCgWxuxYOvyXBurIJtSdcoiIHDcsGpdENCC0J1SrTLWsnB7ILKAWyqSMO2buyOiZS7LsI
BygD5vGyhST2+LIFxz9k2cA3D8OjfvRQBGgHcMSwC/oWrbsQYISBfrvABcS4K+G+h/0iigDZ
j8C7dhwP/0zERw7FQ48jFu6yNkLcrHS7EgAIsKDAypYi4EHMYmAlxY/sEoxSJhKDzRaBvLWA
GZSdgQM8L8ZrgHWBVm0pnrYp8bXFnRLKLiRUMNEAQEbLSEjhNoJf3BH3ZlUkwcBAU6cQaR6k
WrUFgr042wEV4WBXJBQTFyvAB3DBXQwALrvaBdSTiMzjREyWRaBhDRERHjyIIAJxFIEnIp9I
67oEaIgkbksBIFcW75GyCIuQqtGziLTg8iIwHWOCgOcCJqgwLqV24Qu/Tc0coWz5urEYGDAc
sctAlvPnpUQ0jiGvPikaaTyADv1BCuqyrGP4mv3E17NP8ZZXQv+RwBE+68mSgv9lYOGRnw8Q
0PccBPcpaMuDJtzWnwmjtdDKLQblg8EA25F3IDsJBnGCTEHsoh8MEkJXoYqvtaCfhi/sJh5U
G13AwG3omDhVAEQWaSSRj4Vi4QkMXjDWRC++EKGEFK6wZI1HZejbCyxugyEGTRb1pQiyzcCe
e9fFN8N8EtpnJY292XgCji+kpRkb8YA3glRnycAeciIoxxwMFdBXwXRXxpmlbVu+8JQsToxw
W3AmPCqcCPZkZ9yke3XIy6AoLNCKBBRQIMGIiyn65qK5NarCACsttwg7eZhgZ6Qj9JWNprI0
ZNdNFu1CgHULBFkTL64xodaFcPZ4o6sqTNonCWVtOEKGk4YFksMuvJJWQBbYsJPkiCQppQUl
jxJgB0iE4Senli1Ye4Kn48a0C6iPctTtiYTBdWAJJOFjEparPhuvDFr95ZBZLyxgVFIwCSVw
vXXl1Q+8/ah5XcFzQqvCjpcCdgFN9RCSlAGpitCTxOpGOYICJhNTQMoGOQASLSTjNUo5o1Ds
1CjChQAAOw==
--$boundary--
HEADER

	$email =~ s|<#STYLE#>|$style|;

	# Naplnanie
	# - textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ /^email-(.*)/;
		my $var = $1;
		$email =~ s|<%$var%>|$val|g;
	}

	# - premennych
	$email =~ s|<%domain-name%>|all domains|;
	$email =~ s|<%day-in%>|$times{$env{lng}}{in}|;

	# SPRACOVANIE
	# -------------------------------------------------------------------------
	# tieto premenne vyuzivam vo vsetkych alebo viacerych castiach
	my $doc; # telo statistik
	my %XSGN; # sem napcham jednotlive casti
	my $linearity; # tuto premennu naplnam v casti DOMAINS ale vyuzivam aj inde !!!
	my $part_name;

	# --------------- DOMAINS ----------------------
	# Cast - typecka v domenach
	$part_name = "domains";
	$XSGN{PART} = <<"PART";
<table id="domains">
	<#LINE_domain#>
	<tr class="tableinfos">
		<th class="summary" colspan="3"><%totalsummary%></th>
		<td class="summary-item"><%total_count%></td>
		<td></td>
		<td class="summary-item"><%total_load_proc%></td>
		<td class="summary-item"><%total_fulltime%></td>
		<td class="summary-item">&nbsp;</td>
	</tr>
	<#LINE_performbus#>
	<#LINE_performload#>
	<#LINE_performproc#>
</table>
PART

	$XSGN{LINE_domain} = <<"TMP_line_domain";
<tr>
	<td colspan="8">&nbsp;</td>
</tr>
<tr class="tableinfos">
	<th colspan="8"><%domain-name%></th>
</tr>
<tr class="tableinfos">
	<th><%domain%></th>
	<th><%subdomain%></th>
	<th><%type%></th>
	<th><%count%></th>
	<th><%load_req%></th>
	<th><%load_proc%></th>
	<th><%fulltime%></th>
	<th><%efectivity%></th>
</tr>
<#LINE#>
<tr class="tableinfos">
		<th class="summary" colspan="3"><%summary%></th>
		<td class="summary-item"><%total_count%></td>
		<td>&nbsp;</td>
		<td class="summary-item"><%total_load_proc%></td>
		<td class="summary-item"><%total_fulltime%></td>
		<td class="summary-item">&nbsp;</td>
</tr>
<#LINE_domain#>
TMP_line_domain

	$XSGN{LINE} = <<"TMP_line";
<tr class="tableinfos">
	<td><%domain%></td>
	<td><%subdomain%></td>
	<td><%type%></td>
	<td><%count%></td>
	<td><%load_req%></td>
	<td><%load_proc%></td>
	<td><%fulltime1%>s <%fulltime2%>%</td>
	<td><%efectivity%></td>
</tr>
<#LINE#>
TMP_line

	# nalejem texty
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ /^stats-$part_name-(.*)/;
		my $var = $1;
		$XSGN{PART} =~ s|<%$var%>|$val|g;
		$XSGN{LINE_domain} =~ s|<%$var%>|$val|g;
	}

	# LISTING: Domeny

	# nastavujem premenne
	my $all_count; 
	my $all_time;
	my $all_proc;
	my $last_domain;

	# spolocne udaje
	my $db0=$main::DB{stats}->Query("
		SELECT
			count(*) AS count,
			SUM(load_req) AS load_req_sum
		FROM TOM.a110_weblog_rqs
		WHERE	reqdatetime LIKE '$times{text}{in}%'
	");
	if (my %db0_line=$db0->fetchhash())
	{
		$all_count=$db0_line{count};
		$all_time=$db0_line{load_req_sum};
		main::_log(5,"$all_count requests in $times{text}{in} ($all_time reqtime)");
	}

	# zrejme nejake predbezne vypocty
	my %dom_full;
	my $db0=$main::DB{stats}->Query("
		SELECT
			domain,
			domain_sub,
			query_TID,
			count(*) AS count,
			SUM(load_proc) AS load_proc_sum,
			SUM(load_req) AS load_req_sum
		FROM TOM.a110_weblog_rqs
		WHERE	domain_sub!=''
					AND reqdatetime LIKE '$times{text}{in}%'
		GROUP BY domain_sub
		ORDER BY load_req DESC
	");
	while (my %db0_line=$db0->fetchhash)
	{
		$dom_full{$db0_line{'domain_sub'}}{'load_proc_sum'}=$db0_line{'load_proc_sum'};
		$dom_full{$db0_line{'domain_sub'}}{'load_req_sum'}=$db0_line{'load_req_sum'};
		$dom_full{$db0_line{'domain_sub'}}{'count'}=$db0_line{'count'};
		main::_log(5, "read $db0_line{'domain_sub'} proc_sum:$db0_line{'load_proc_sum'} req_sum:$db0_line{'load_req_sum'} count:$db0_line{'count'}");
	}

	# tu uz je LISTING
	my $db0=$main::DB{stats}->Query("
		SELECT
			domain,
			domain_sub,
			query_TID,
			count(*) AS count,
			AVG(load_proc) AS load_proc,
			AVG(load_req) AS load_req,
			SUM(load_proc) AS load_proc_sum,
			SUM(load_req) AS load_req_sum
		FROM TOM.a110_weblog_rqs
		WHERE	domain_sub!=''
					AND reqdatetime LIKE '$times{text}{in}%'
		GROUP BY domain, domain_sub, query_TID
		ORDER BY domain,domain_sub,load_req DESC
	");

	# premenne pre jednotlive domeny
	my $dom_proc;
	my $dom_money;
	my $dom_count;
	my $dom_time;

	my $db0_numrows = $db0->numrows;
	my $db0_i = 0;
	while ( my %db0_line = $db0->fetchhash )
	{
		$db0_i++;
		if ( $last_domain ne $db0_line{domain_sub} )
		{
			# zmenila sa domena
			if ( $last_domain )
			{
				my %total_vars = (
					'total_count' => (sprintf("%d", $dom_count)),
					'total_load_proc' => (sprintf("%d", $dom_proc)),
					'total_fulltime' => (sprintf("%d", $dom_time)),
					'total_money' => $dom_money,
				);
				# tu poslednu naplnim sumarnymi datami
				$dom_money = int($dom_money*100)/100; # dom_money este upravim (mozem, ved aj tak ho zas nulujem)
				$XSGN{NULL} =~ s|<%domain-name%>|$last_domain|g;
				while ( (my $key, my $val) = each %total_vars) { $XSGN{NULL} =~ s|<%$key%>|$val|; }
				$XSGN{NULL} =~ s|<#LINE#>||g;
				$dom_count=0;
				$dom_time=0;
				$dom_proc=0;
				$dom_money=0;
				$XSGN{PART} =~ s|<#LINE_domain#>|$XSGN{NULL}|;
			}
		
			# pokracujem dalsou
			$XSGN{NULL} = $XSGN{LINE_domain};
		}

		# zostavujem LINE
		my $null = $XSGN{LINE};
		my %null_vars;

		# vypocty
		my $p_count = sprintf( "%2.2f", ( $db0_line{count} / ( $dom_full{$db0_line{'domain_sub'}}{'count'} / 100 ) ) );
		my $p_req = sprintf( "%2.2f", ( $db0_line{load_req_sum} / ( $dom_full{$db0_line{'domain_sub'}}{'load_req_sum'} / 100 ) ) );
		my $money = sprintf( "%2.2f", ($money_86400*($db0_line{load_req_sum}/$all_time)) );
	
		$all_proc += $db0_line{load_proc_sum};
		$dom_count += $db0_line{count};
		$dom_time += $db0_line{load_req_sum};
		$dom_proc += $db0_line{load_proc_sum};
		$dom_money += $money;

		# naplnim premenne
		$null_vars{domain} = $db0_line{domain};
		$null_vars{subdomain} = $db0_line{domain_sub};
		$null_vars{type} = $db0_line{query_TID};
		$null_vars{count} = $db0_line{count};
		$null_vars{count_perc} = $p_count;
		$null_vars{load_req} = sprintf( "%2.2f", (int($db0_line{load_req}*10000))/10000);
		$null_vars{load_proc} = sprintf( "%2.2f", (int($db0_line{load_proc}*10000))/10000);
		$null_vars{fulltime1} = sprintf( "%2.2f", (int($db0_line{load_req_sum}*10))/10);
		$null_vars{fulltime2} = $p_req;
		if ( $p_req > 0 ) { $null_vars{efectivity} = sprintf( "%2.2f", int( ( $p_count/$p_req )*100 ) / 100 ); }
		else { $null_vars{efectivity} = "0"; }
		$null_vars{money} = sprintf("%7s",sprintf("%4.2f",$money));

		# vlozim data do LINE
		while ( (my $key, my $val) = each %null_vars )
		{
			$null =~ s|<%$key%>|$val|g;
		}
		# a LINE do LINE_domain
		$XSGN{NULL} =~ s|<#LINE#>|$null|g;

		if ( $db0_numrows == $db0_i )
		{
			my %total_vars = (
				'total_count' => (sprintf("%d", $dom_count)),
				'total_load_proc' => (sprintf("%d", $dom_proc)),
				'total_fulltime' => (sprintf("%d", $dom_time)),
				'total_money' => $dom_money,
			);
			# tu poslednu naplnim sumarnymi datami
			$dom_money = int($dom_money*100)/100; # dom_money este upravim (mozem, ved aj tak ho zas nulujem)
			$XSGN{NULL} =~ s|<%domain-name%>|$last_domain|g;
			while ( (my $key, my $val) = each %total_vars) { $XSGN{NULL} =~ s|<%$key%>|$val|; }
			$XSGN{NULL} =~ s|<#LINE#>||g;
			$dom_count=0;
			$dom_time=0;
			$dom_proc=0;
			$dom_money=0;
			$XSGN{PART} =~ s|<#LINE_domain#>|$XSGN{NULL}|;
		}

		$last_domain=$db0_line{domain_sub};
	}
	$XSGN{PART} =~ s|<#LINE_domain#>||;
	$XSGN{PART} =~ s|<#LINE#>||;

	# Teraz vlozim data do PART
	my %part_vars;

	# pozor, linearity je vyuzivana aj dalej !!!
	$linearity = sprintf( "%2.2f", int(($all_time/(86400/100))*100)/100 );

	$part_vars{total_count} = sprintf( "%d", $all_count);
	$part_vars{total_load_proc} = sprintf( "%d", $all_proc);
	$part_vars{total_fulltime} = sprintf( "%d", $all_time);
	$part_vars{total_efectivity} = sprintf( "%2.2f", int($money_86400*100)/100 );
	$part_vars{total_load_proc_perc} = sprintf( "%2.2f", int(($all_proc/(86400/100))*100)/100 );
	$part_vars{total_fulltime_perc} = $linearity;
	$part_vars{total_efectivity_s} = "/86400s";

	# nalejem premenne
	while ( (my $key, my $val) = each %part_vars )
	{
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}

	# vymazem vsetky prazdne riadky
	$XSGN{PART} =~ s|[\n]+|\n|gi;

	$doc .= $XSGN{PART};

	# SUMAR K DOMAINS

	main::_log(5,"selecting requests from primetime (60 minuts)");
 
	# Vypocty
	my $business_req=0.3;
	my $max_second;
	my $max_second_abs;
	my $max_second_datetime;

	my $sel_visits;
	my $sel_reqtime;
	my $sel_load;
	my $db0=$main::DB{stats}->Query("
	SELECT
		reqdatetime,
		SUM(visits) AS visits,
		AVG(load_req) AS load_req_avg
	FROM $TOM::DB_name_STAT.a110_weblog_min
	WHERE	domain_sub!=''
				AND reqdatetime LIKE '$times{text}{in}%'
	GROUP BY reqdatetime
	ORDER BY visits DESC
	LIMIT 60
	");
	while (my %db0_line=$db0->fetchhash)
	{
		main::_log(6,"requests from $db0_line{reqdatetime}: $db0_line{visits} (".($db0_line{load_req_avg}*$db0_line{visits})." reqtime)");
		
		my $load=1;
		my $db1=$main::DB{stats}->Query("
			SELECT
				load_1min
			FROM TOM.a110_load_min
			WHERE reqdatetime LIKE '$db0_line{reqdatetime}%'
			LIMIT 1");
		if (my %db1_line=$db1->fetchhash)
		{
			$load=$db1_line{load_1min};
		};
		main::_log(7,"load $load");
		$sel_load+=$load;
		
		
		
		$sel_visits+=$db0_line{visits};
		$sel_reqtime+=($db0_line{load_req_avg}*$db0_line{visits});
	}
	main::_log(5,"total requests $sel_visits in primetime ($sel_reqtime total reqtime in 3600s) (avg load ".($sel_load/60).")");
	main::_log(5,"avg reqtime to 1 request in primetime is ".($sel_reqtime/$sel_visits)." norma is $business_req");

=head1
	my $reserve=$max_second/($all_count/$all_time);
	#$doc.="teoretical reserve: $reserve\n";
	
	$doc.="--[ business performance (by primetime request time) ]------------------------------------------------------\n";
	
	$doc.="                                                            ";
	$doc.=sprintf("%10d",int($all_count*$reserve))." ";
	$doc.="       ";
	$doc.=sprintf("%10d",int($all_proc*$reserve))."s ";
	$doc.="";
	$doc.=sprintf("%8d",int($all_time*$reserve))."s ";

	$doc.="\n";
=cut

	# Business Performance
	$part_name = "performbus"; # nazov tejto casti
	# design
	$XSGN{PART} = <<"PART";
<tr>
	<th colspan="8">&nbsp;</th>
</tr>
<tr class="tableinfos">
	<th colspan="8"><%header%></th>
</tr>
<tr class="tableinfos">
		<th class="summary" colspan="3">&nbsp;</th>
		<td class="summary-item"><%count%></td>
		<td>&nbsp;</td>
		<td class="summary-item"><%proc%></td>
		<td class="summary-item"><%time%></td>
		<td class="summary-item">&nbsp;</td>
</tr>
PART
	my %part_vars = (); # sem ulozim vypocty
	my $reserve=($business_req/($all_time/$all_count));
	$part_vars{count} = int($all_count*$reserve);
	$part_vars{proc} = int($all_proc*$reserve);
	$part_vars{time} = int($all_time*$reserve);
	# naplnenie textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ s|^stats-$part_name-||;
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}
	# naplnenie hodnot
	while ( (my $key, my $val) = each %part_vars ) { $XSGN{PART} =~ s|<%$key%>|$val|g; }
	# vsetko to vlozim do dokumentu
	$doc =~ s|<#LINE_performbus#>|$XSGN{PART}|;
	

	# Load Performance
	$part_name = "performload"; # nazov tejto casti
	# design
	$XSGN{PART} = <<"PART";
<tr>
	<th colspan="8">&nbsp;</th>
</tr>
<tr class="tableinfos">
	<th colspan="8"><%header%></th>
</tr>
<tr class="tableinfos">
		<th class="summary" colspan="3">&nbsp;</th>
		<td class="summary-item"><%count%></td>
		<td>&nbsp;</td>
		<td class="summary-item"><%proc%></td>
		<td class="summary-item"><%time%></td>
		<td class="summary-item">&nbsp;</td>
</tr>
PART
	my %part_vars = (); # sem ulozim vypocty
	my $reserve=1/($sel_load/60);
	$part_vars{'count'} = int($all_count*$reserve);
	$part_vars{'proc'} = int($all_proc*$reserve);
	$part_vars{'time'} = int($all_time*$reserve);
	# naplnenie textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ s|^stats-$part_name-||;
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}
	# naplnenie hodnot
	while ( (my $key, my $val) = each %part_vars ) { $XSGN{PART} =~ s|<%$key%>|$val|g; }
	# vsetko to vlozim do dokumentu
	$doc =~ s|<#LINE_performload#>|$XSGN{PART}|;

	# ------------------------
	# Processor Performance
	$part_name = "performproc"; # nazov tejto casti
	# design
	$XSGN{PART} = <<"PART";
<tr>
	<th colspan="8">&nbsp;</th>
</tr>
<tr class="tableinfos">
	<th colspan="8"><%header%></th>
</tr>
<tr class="tableinfos">
		<th class="summary" colspan="3">&nbsp;</th>
		<td class="summary-item"><%count%></td>
		<td>&nbsp;</td>
		<td class="summary-item"><%proc%></td>
		<td class="summary-item"><%time%></td>
		<td class="summary-item">&nbsp;</td>
</tr>
PART
	my %part_vars = (); # sem ulozim vypocty
	my $reserve=100/($all_proc/(86400/100));
	$part_vars{count} = int($all_count*$reserve);
	$part_vars{proc} = int($all_proc*$reserve);
	$part_vars{time} = int($all_time*$reserve);
	# naplnenie textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ s|^stats-$part_name-||;
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}
	# naplnenie hodnot
	while ( (my $key, my $val) = each %part_vars ) { $XSGN{PART} =~ s|<%$key%>|$val|g; }
	# vsetko to vlozim do dokumentu
	$doc =~ s|<#LINE_performproc#>|$XSGN{PART}|;

	# ------------------------
	# Average Request Time
	$part_name = "reqtavg"; # nazov tejto casti
	# design
	$XSGN{PART} = <<"PART";
<table id="reqtavg">
	<tr>
		<th colspan="2"><%header%></th>
	</tr>
	<tr>
		<td><%total%></td><td><%total-val%>s</td>
	</tr>
	<tr>
		<td><%primetime%></td><td><%primetime-val%>s</td>
	</tr>
	<tr><td>*)</td><td><%note1%></td></tr>
	<tr><td>*)</td><td><%note2%></td></tr>
	<tr><td>*)</td><td><%note3%></td></tr>
</table>
PART
	my %part_vars = (); # sem ulozim vypocty
	$part_vars{'total-val'} = ((int(($all_time/$all_count)*100))/100);
	$part_vars{'primetime-val'} = ((int(($sel_reqtime/$sel_visits)*100))/100);
	# naplnenie textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ s|^stats-$part_name-||;
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}
	# naplnenie hodnot
	while ( (my $key, my $val) = each %part_vars ) { $XSGN{PART} =~ s|<%$key%>|$val|g; }
	# vsetko to vlozim do dokumentu
	$doc .= $XSGN{PART};

	# ------------------------
	# Paralel requests
	$part_name = "parreq"; # nazov tejto casti
	# design
	$XSGN{PART} = <<"PART";
<table id="parreq">
	<tr>
		<th colspan="2"><%header%></th>
	</tr>
	<tr>
		<td><%parreq%></td><td><%parreq-val%>%</td>
	</tr>
	<tr><td>*)</td><td><%note1%></td></tr>
</table>
PART
	my %part_vars = (); # sem ulozim vypocty
	$part_vars{'parreq-val'} = $linearity;
	# naplnenie textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ s|^stats-$part_name-||;
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}
	# naplnenie hodnot
	while ( (my $key, my $val) = each %part_vars ) { $XSGN{PART} =~ s|<%$key%>|$val|g; }
	# vsetko to vlozim do dokumentu
	$doc .= $XSGN{PART};

	# ------------------------
	# Request Time
	$part_name = "reqt"; # nazov tejto casti
	# design
	$XSGN{PART} = <<"PART";
<table id="reqt">
	<tr>
		<th colspan="4"><%header%></th>
	</tr>
	<#LINE#>
</table>
PART

	$XSGN{LINE} = <<"TMP_line";
<tr><td><%first%></td><td><%ttt%></td><td><%per%></td><td><%count%></td></tr>
<#LINE#>
TMP_line

	my %part_vars = (); # sem ulozim vypocty
	# naplnenie textov
	while ( (my $key, my $val) = each %{$TEXTS{$env{lng}}} )
	{
		next unless $key =~ s|^stats-$part_name-||;
		$XSGN{PART} =~ s|<%$key%>|$val|g;
	}

	for my $tt (1..10)
	{
		my $ttt=$tt/10;
		my $db0=$main::DB{stats}->Query("
		SELECT count(*) AS count FROM TOM.a110_weblog_rqs WHERE reqdatetime LIKE '$times{text}{in}%' AND reqtype='B' AND load_req<=$ttt AND load_req>".($ttt-0.1)." LIMIT 1");
		if (my %db0_line=$db0->fetchhash())
		{
			$XSGN{NULL} = $XSGN{LINE};
			$part_vars{first} = "&lt;";
			$part_vars{ttt} = $ttt;
			$part_vars{per} = sprintf("%02.2f",$db0_line{count}/($all_count/100));
			$part_vars{count} = $db0_line{count};
			#$doc.="  > 2.0s ".($per)."% ($db0_line{count})\n";
			# naplnenie hodnot
			while ( (my $key, my $val) = each %part_vars ) { $XSGN{NULL} =~ s|<%$key%>|$val|g; }
			$XSGN{PART} =~ s|<#LINE#>|$XSGN{NULL}|;
		}
	}
	my $db0=$main::DB{stats}->Query("
		SELECT count(*) AS count FROM TOM.a110_weblog_rqs WHERE reqdatetime LIKE '$times{text}{in}%' AND reqtype='B' AND load_req>1 LIMIT 1");
	if (my %db0_line=$db0->fetchhash())
	{
		$XSGN{NULL} = $XSGN{LINE};
		$part_vars{first} = "&gt;";
		$part_vars{ttt} = 1;
		$part_vars{per} = sprintf("%02.2f",$db0_line{count}/($all_count/100));
		$part_vars{count} = $db0_line{count};
		#$doc.="  > 2.0s ".($per)."% ($db0_line{count})\n";
		# naplnenie hodnot
		while ( (my $key, my $val) = each %part_vars ) { $XSGN{NULL} =~ s|<%$key%>|$val|g; }
		$XSGN{PART} =~ s|<#LINE#>|$XSGN{NULL}|;
	}
	$XSGN{PART} =~ s|<#LINE#>||;
	#$doc.="avg requests per seccond: ".((int(($all_count/$all_time)*100))/100)."s \n";
	#$doc.="max requests per seccond: ".(int($max_second*100)/100)."s \n";

	# vsetko to vlozim do dokumentu
	$doc .= $XSGN{PART};

	
	#$doc.="\n";
	#print $doc."\n";

	# toto je len testovacie !!!
	$doc =~ s|<td(.*?)>[\s]*?</td>|<td$1>&nbsp;</td>|gm;
	
	# --------- ZAVERECNE SPRACOVANIE -------------
	$email=~s|<#BODY#>|$doc|;
	use Utils::datetime;
	$email =~ s|<%SUBJECT%>|$TEXTS{$env{lng}}{'headers-subject'}|g;
	
	
	# spracovanie emailovych adries
	use TOM::Utils::vars;
	$env{to_email}=TOM::Utils::vars::unique_split($env{to_email});
	$env{to_email_parse}=$env{to_email};
	$env{to_email_parse}=~s|;|>,<|g;$env{to_email_parse}="<".$env{to_email_parse}.">";
	
#	my %env0;
#	foreach ( split ';', $env{to_email} ) { $env0{$_}++; }
#	$env{to_email}="";foreach (sort keys %env0){$env{to_email}.=$_.";" if $_}$env{to_email}=~s|;$||;
#	$env{to_email_parse}=$env{to_email};$env{to_email_parse}=~s|;|>,<|g;$env{to_email_parse}="<".$env{to_email_parse}.">";
	
	
	
	$email=~s|<%TO%>|$env{to_email_parse}|g;

	$email=~s|\'|\\'|g; # vyescapujem apostrofy

	#print $email;
	#print $XSGN{PART};

	main::_log(5, $email);

	#return 1; # nechcem mail posielat, iba vidiet

	# POSIELAM MAIL
	if
	(
		# sendtime='$main::time_current'
		# priority=0
		# from_name='CRON'
		# from_email='TOM\@$TOM::hostname'
		# from_host='$tom::H'
		# from_service='a110' a400 a300
		# to_name = ''
		$main::DB{main}->Query("
			INSERT INTO TOM.a130_send
			(
				sendtime,
				priority,
				from_name,
				from_email,
				from_host,
				from_service,
				to_name,
				to_email,
				body)
			VALUES	(
				'$main::time_current',
				'0',
				'CRON',
				'TOM\@$TOM::hostname',
				'$tom::H',
				'a110',
				'',
				'$env{to_email}',
				'$email'
			)
		")
	)
	{
		# ak sa mi podarilo mail vlozit do db (poslat)
		#print "ok\n";
		main::_log(5,"email sent");
	}
	else
	{
		# nepodqarilo sa to
		#print "err\n";
		main::_log(5,"email not sent");
	}
 
	return 1}

1;
